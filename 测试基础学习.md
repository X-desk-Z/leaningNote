# 测试基础学习

## 前进不止

学习目标：做一个点炒饭不会爆炸的酒吧

笔记来源：[进阶自动化测试 b](https://www.bilibili.com/video/BV1464y1x7uH?p=4)



开发规范：

- [开发规范](https://blog.csdn.net/JobsandCzj/article/details/78049526?ops_request_misc=%7B%22request%5Fid%22%3A%22163688321916780274130321%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=163688321916780274130321&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-78049526.first_rank_v2_pc_rank_v29&utm_term=开发规范&spm=1018.2226.3001.4187)
- [高性能Java代码的规范 ](https://www.cnblogs.com/luao/p/10848777.html)

序列化：[序列化和反序列化](https://blog.csdn.net/tree_ifconfig/article/details/82766587?ops_request_misc=%7B%22request%5Fid%22%3A%22163688982316780255261198%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=163688982316780255261198&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82766587.first_rank_v2_pc_rank_v29&utm_term=序列化&spm=1018.2226.3001.4187)

QA：[QA与测试](https://blog.csdn.net/liming363873117/article/details/52423238?ops_request_misc=&request_id=&biz_id=102&utm_term=QA&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-52423238.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)

[测试面试题](https://www.jianshu.com/p/4a35edb0c106)

[接口测试痛点](https://zhuanlan.zhihu.com/p/139587197)

[面试测试总结  （大全）](https://www.cnblogs.com/jingsiqing/p/9726457.html)

[软件测试](https://www.kdocs.cn/view/p/141734772719)



### **测试定义：**

- 软件测试是指使用**人工或自动化**的手段来运行或测试某个系统的过程。其目的在与检验系统能否**满足规定需求**或理清**预期结果与实际结果**间的差别
- 为了**发现错误**而执行程序的过程
- 利用根据软件开发各阶段的规格说明或内部结构设计的**测试用例**来运行程序以及**发现错误**的过程
- 根本目的是**证明软件存在错误**，而并非是证明软件没有错误
- 好的软件测试用例在于其**可以发现至今未被发现的错误**
- 成功的软件测试工作也在于其**可以发现至今未被发现的错误**



### **测试目的：**

- 发现隐藏在软件中的**错误或缺陷**，并将其**修复**。
- 最大程度满足软件需求，**提高用户满意度**。
- 提升软件质量。



### 测试原则：

1. 测试活动应该以**用户需求为标准**，部分经验指导用户需求
2. 执行软件测试前，应当准备好**测试用例**，也就是**测试数据**与**对应预期结果**二者的组合。
3. **尽早进行测试**，减少修复成本，覆盖整个软件生命周期
4. 严格执行测试计划，**避免测试随意性**（分工合作）
5. 测试用例注重考虑到**合法的输入和不合法的输入**，以及各种边界值，特殊情况下还需要做的**极端状态和意外状态**
6. 避免检查自己的代码
7. **杀虫剂效应**（抗药性）【换个思维方式换个操作路径，切换视角】
8. **免疫性**：每修改 **3 - 5** 个错误或缺陷，就会引入 **1** 个新的错误或缺陷
9. **二八原则** ：大部分问题出现在热区
10. 妥善保存测试中的所有文档（计划，用例，数据，错误统计，分析报告）
11. 对问题一定要有一个确定的过程以及一个确定正确的状态（挥手，握手）
12. 软件的错误与缺陷会随着测试工作的进展而逐渐**减少**，但是需要花费的资金也会逐渐**增加**。一般情况下，**完全要求软件没有任何的错误与缺陷是没有必要的，应当选择资金花费与剩余错误、缺陷数量相平衡的 “Good Enough” 位置终止测试**





### **软件测试的对象**：

- 需求说明**文档**

- 概要设计文档

- 详细设计文档

- **程序**

- **数据**

- 用户文档

  “软件测试**包含**程序测试，但**不等于**程序测试。软件测试也包含了对**文档**与**数据**的测试。”

  软件=程序+数据+文档 





### **[测试执行流程与规范](https://blog.csdn.net/qq_36697780/article/details/118415583?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant)：**

1. 参加需求评审会议 :arrow_down:——>需求分析
2. 拟定软件测试计划 :arrow_down:——>测试计划？
3. 测试设计与开发 :arrow_down:——>测试方案与工具选择？
4. 实施软件测试 :arrow_down:——>执行
5. 测试评估 :arrow_down:——>[测试质量评估与度量_](https://blog.csdn.net/weixin_34071713/article/details/93319229?ops_request_misc=&request_id=&biz_id=102&utm_term=测试评估&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-93319229.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)
6. 测试总结 :triangular_flag_on_post:——>小作文



#### 1️⃣**拟定测试计划：**

 **对即将开展的测试工作进行整体的安排**（例如资金、资源、人员的分配，准备测试用例等）

**主要工作：**

- 仔细研究软件规格说明文档（需求文档）。
- 将等待测试的软件产品分解为可以独立测试的单元。
- 确定每个单元需要采用的测试技术。
- 制定下一阶段测试工作的计划。



#### 2️⃣**测试设计与开发：**

分析**测试需求**，设计**测试用例**，准备**测试数据**，开发**测试代码**，搭建**测试环境**

- **测试用例**：是一组条件或变量，测试工程师可以根据其来确认软件是否可以正确工作。**测试用例一般由测试输入、测试标准、预期结果等内容组成**。本质上，测试用例可以将被测对象的功能和特性进行**细化**与**展开**，可以保证软件功能**不被遗漏或重复测试**，也可以使软件测试的效果不完全依赖于测试工程师的个人能力，便于组织更加合理的安排测试人员
- **测试数据**直接影响测试工作的总体质量，也是影响测试环境的因素之一。测试数据由测试工程师、DBA 或开发工程师编写，一般来源于自行编写、利用已有系统中的数据或利用非电子化的业务数据。一般情况下，**软件功能测试**不需要大量的数据，但是需要数据的覆盖率与真实度尽可能高；**软件性能测试**则需要大量的数据，并且数据量应当尽可能符合实际情况。



#### 3️⃣**实施软件测试**：

在执行测试用例的过程中，如果发现了错误和缺陷的话，应当记录并提交**缺陷报告**。

实施软件测试的过程主要分为以下**三个阶段**：

- **初测期**：测试主要功能与关键执行路径，排除**主要障碍**。
- **细测期**：根据测试计划与测试用例，**逐一测试所有的**功能、特性、性能、界面、兼容性、可用性等测试点。
- **回归测试期**：软件已经趋于稳定，在测试过程中可以发现的新的错误与缺陷已经非常有限。**此时应当复查已知错误与缺陷的纠正情况，确认未引入新的缺陷时即可终止回归测试**。

**缺陷报告应当包括以下内容**：

- 记录问题发生时的环境
- 记录问题的重现步骤
- 说明问题的性质
- 给出相应的改进建议
- 随时记录问题的处理进度



#### 4️⃣**测试评估与总结：**

评估**软件产品质量**、评估**测试人员工作情况**。

总结**测试情况**，编写**软件测试报告**。



#### [> ^ <]

|          |         |   [> ~ <]

|          |         |  

|          |         |加油加油

|          |         |还有一大堆要学呢

|          |         |

|          |         |  【^-^】



​         



#### **软件测试计划**：

**软件测试计划**：指的是在软件测试工作正式实施前先行**仔细研究测试对象**，并且通过对**资源、时间、风险、测试范围和预算**等多方面因素进行**综合分析与规划**，以确保测试工作可以**有效实施**

**软件测试计划的用途**：

- 将过去总结的知识与经验转化为执行测试任务的具体方案。
- 为组织、安排与管理测试项目提供整体框架。
- 促进测试团队成员间开展有关任务与过程的交流。
- 对项目风险进行分析，并得出相应的应对策略。

**软件测试计划应当尽早制定，一般在软件需求文档确定后即开始制定测试计划**。测试计划在整个的测试流程中处于 **“核心位置”**，是可以开展准备与执行测试工作的**必要条件**，是保证测试工作质量的**根本基础**。

在制定软件测试计划后，应当由组织的测试经理（高级测试工程师）团队进行**评审**。在测试工作开展的过程中，应当时刻对照确认当前测试工作是否 **“正在按照测试计划进行”**。测试计划不是一成不变的，如果在实践过程中发现计划确实存在不足需要改进的话，应当进行调整与修改。

**软件测试计划的基本结构**：

1. 测试计划简介

2. 测试项目说明

3. **测试范围**

4. **测试手段和策略**

5. 项目通过或失败的标准

6. 暂停与重启测试工作的标准

7. 测试的可交付性

8. **测试任务分配**

9. 环境需求

10. 职责

11. 人员与培训需求

12. **进度表**

13. **风险与偶然事故的解决方案**

    

    ```
    “软件测试计划的价值取决于其能够在多大的程度上帮助测试团队**管理项目 / 发现错误与缺陷**。不能为了制定计划而制定计划，不能简单的套用模板，这样是没有意义的”
    ```

    

#### 软件测试环境：

软件应当在 **“最终用户环境”**（用户实际运行软件时**一定会**或**最有可能**使用的环境）下进行测试



##### 测试环境搭建原则

搭建测试环境**四要素**：

- 真实
  - **项目软件**（面向某个企业、部门或团队开发的软件）与**产品软件**（面向整个社会或社会中的部分群体开发的软件）所需的测试环境**有所不同**，需要用不同的思维进行分析。
- 干净
  - 测试环境中**没有**其他占用资源的应用程序。
- 独立
  - 开发环境与测试环境应当是**相互独立**的。独立环境可以避免在开发环境下执行的操作**误删改**用于测试软件的特殊数据，避免发生冲突。
- 无毒
  - 测试环境中**没有**病毒。



##### 测试前的准备：

- 软件配置
  - 准备好被测试的主体，需求文档，设计文档，源代码
- 测试配置
  - 测试环境，计划，用例
- 测试工具
  - 自动化的话，准备好数据生成，静态分析，动态分析，结果分析，测试驱动数据库。等
- 软件测试的周期性是指**测试、修复、回归测试、再修复**这样的一个循环过程。
  - **串行测试**（使用最广）
  - **并行测试**（效率最高）



#### 测试停止的依据：

**推荐标准**：**是否停止软件测试，应当根据单位时间内发现错误或缺陷的数量与严重程度进行决定**。

**不推荐（错误）标准**：

1. 超过了测试的预定时间即停止测试。
2. 所有测试用例执行完毕但未发现错误或缺陷即停止测试。
3. 直接指出停止测试的具体要求，例如发现 XX 数量的故障或缺陷后即停止测试。

##### 推荐标准

1. **缺陷修复率标准**
   - **高严重性**错误或缺陷修复率达到 **100%**
   - **中等严重性**错误或缺陷修复率达到 **80%** 以上
   - **低严重性**错误或缺陷的修复率达到 **60%** 以上
2. **覆盖率标准**
   - **语句覆盖率**达到 **80%** 以上
   - 测试**用例**执行覆盖率达到 **100%**
   - 测试**需求**执行覆盖率达到 **100%**





### 常见软件开发模型类型

- 以**软件需求完全确定**为前提的 **“第一代”** 软件开发模型。
- 在开始阶段只能**提供基本需求**的 **“渐进式”** 软件开发模型。
- 以**体系结构**为基础的基于 **“构件组装”** 的软件开发模型。



**V 模型的局限性**：测试工作只能在编码完成后才能开展，不能做到测试与开发工作并行，测试工作过于**落后**。

**V 模型的改进**：V 模型 + 各阶段同步开展测试工作 = **W 模型**



W 模型是 V 模型的自然发展。W 模型强调了 **“软件测试流程应当伴随完整的软件开发过程同步进行”**，同时也指明了**软件测试的对象不仅仅是程序本身，还包含着软件的需求、功能与设计部分**。

**W 模型的局限性**：W 模型仍然是线性流程，**缺少迭代**。前一项测试工作（例如单元测试）结束前，**无法提前执行**下一项（例如集成测试）测试



H 模型强调了 **“软件测试是一个独立的流程，应当尽早准备、尽早执行”**。同时也指明了**软件测试是根据被测对象的不同而分层次执行的，不同层次的测试流程可以按照某个次序先后进行，也可以反复执行**。H 模型在相应条件具备时可以直接开展测试工作，没有严格或线性的执行顺序。



### 软件质量的概念、范围与标准：

**软件质量**：是指软件**符合**

- **文档或用户明确描述的功能、性能需求与开发标准**，
- 以及 **专业软件应当具备的隐含特征** 的程度

软件质量可以反映以下**三方面**问题：

1. **软件需求**
2. **开发标准**
3. **隐性需求**

软件质量的评定范围可以使用 **“3A”** 进行表示。

- **Accountability (可说明性)**：用户可以基于软件的描述或定义进行使用。
- **Availability (有效性)**：软件对于绝大多数用户来说总是有效的。
- **Accessibility (易用性)**：软件容易使用、功能非常有用。



以**用户**的角度评定软件质量，主要有以下几点：

- 软件是否具有**所需功能**
- 软件**可靠程度**如何
- 软件**效率**如何
- 软件的使用是否**方便**
- 软件的**环境开放程度**如何

以**开发者**的角度判定软件质量，主要有以下几点：

- 软件是否易于**维护**
- 软件是否易于**移植**
- 软件是否易于**重用**
- 软件是否易于**测试**



------





### **测试的分类：**

#### **按技术分**：

白（白盒测试，亦称程序员测试、结构测试、逻辑驱动测试），黑（黑盒测试 ，亦称用户测试、功能测试、数据驱动测试），灰

- ***白色***：观心软件内部设计和程序实现（处理过程），主要测试依据是设计文档，“看代码逻辑是否正确是否会有异议”（白盒现在一般开发的活）
  
  - **要求**/**规划**：根据程序的内部结构，如控制语句的结构，模块间的控制结构以及内部数据结构进行测试。
  - **优点**：能对程序内特定部位进行覆盖测试
  - **缺点**：无法检验程序的外部特征，无法对未实现规格说明那个的程序欠缺部分进行测试
  - **方法**：语句覆盖，判定覆盖，条件覆盖，判定—条件覆盖，基本路径覆盖，循环覆盖
  
- ***黑色***：从软件外部对软件实施的测试，，其基本观点是：任何程序都可以看作是从输入定义域到输出值域的映射，这种观点将被测程序看作一个打不开的黑盒，黑盒里面的内容 (实现) 是完全不知道的，只知道软件要做什么

  ”不关心内部代码实现，只关心输入后的输出是否正常，是否符合需求文档的要求“

  - **要求/规划**：根据需求文档，争对命令，信息，报表等用户界面及体现他们的输入数据与输出数据之间的对应关系，特别是争对功能测试
  - **优点**：站在用户的角度上来测试（假设程序员是自大的）
    - 黑盒测试与软件的具体实现过程无关，如果实现过程发生了变化，测试用例与数据仍然可以正常使用
    - 黑盒测试的测试用例设计可以与软件的开发工作同时进行，可以压缩项目的总开发时间
  - **缺点**：无法覆盖全部（无法测试软件内部特定部位，如果规格有误，则无法发现【炒饭】）
  - **方法**：基于图的测试，等价类划分，边值分析，比较测试

- 灰色：关注输入与输出的正确性，同时也关注内部代码的实现  --“接口测试”

“黑盒很像一个接口，你只管输入数据，我来处理，你不用管过程有多麽艰辛 ‘生活美好，是因为她人为你负重前行 ’ ”



#### **按测试阶段分：**

单元测试，集成测试，系统测试，验收测试（正式验收测试，α测试（内测），β测试（公测））

- **单元测试：**粒度是最小的，小到一个类一个函数，测试单元是否符合‘设计文档'(详细设计文档)
  - 测试内容：规范，逻辑，路线
- **集成测试：**介于单元和系统之间，起到桥梁作用（多个单元间的耦合），主要测试**模块**（多个单元组成1模块{单元间的模块有着调用或被调用的关系（单元间的联系/连结）}），采用**灰盒**测试，既要验证”设计（概要设计文档）“又要验证”需求“ ——>“接口测试”
  - 测试内容：接口，路径，功能，性能
- **系统测试**：根据 **需求规格说明书** 使用黑盒来测试
  - 测试内容：功能，界面，安全，兼容性，易用性，性能，压力，负载，恢复，（App：后台，组件冲突【音乐】）
- **验收测试**——>**黑盒**，α和β也是站在终端用户的角度来测试。
  - α：公司内部员工模拟用户，属于可控的环境中测试
  - β：公测是在开发者无法控制的情况下进行的软件现场应用（炒饭出现的几率高一点）
- **正式验收测试**：用户在实际使用环境下进行的测试——>关乎尾款

“从小到大，由内至外，循序渐进（分治思想）”



#### **被测对象是否需要运行起来**：

静态测试，动态测试（文档检查，[代码审查 代码走查_代码走查](https://blog.csdn.net/weixin_31484477/article/details/81074198)，界面检查）

- ##### **静态测试**：

  - 文档检查：文档测试（术语，图片，操作流程） ——>测试人员
  - 程序测试：开发交叉检查彼此的代码 ——>发现代码层面的问题
    - 代码检查：检查代码风格是否符合规范
    - 静态结构检查：检查算法是否有优化空间，车光绪函数逻辑是否存在错误
    - 代码质量度量：使用人工或软件工具检查程序代码质量是否符合设计标准
  - 界面检查：测试软件的实际界面是否与需求文档中的说明界面完全相符
  - **静态结构分析：**
    - 将软件程序内部结构抽象未图形（例如函数调用图，函数内部控制流程图等）

###### **静态测试阶段的主要活动**：

- 检查**算法逻辑**是否正确。
- 检查**模块接口**是否正确。
- 检查函数是否对输入参数进行了**合法性检查**。
- 检查程序能否对**异常或错误**进行适当的处理。
- 检查代码**表达式与语句**是否准确并且**不存在二义性**。
- 检查**常量与全局变量**的使用是否符合规范。
- 检查**标识符**的使用是否符合规范。
- 检查程序**代码风格**的**一致性、规范性**（擅用换行和空格）。
- 检查代码是否仍然可以继续**优化** (**算法效率**是否足够高)。
- 检查代码**注释**是否**完整且规范**，是否可以准确的反映代码功能



##### **动态测试**：

- 通过人工或手动实用工具运行程序分析程序执行状态和输出情况（黑白灰），向其中**输入测试数据**，检查**实际输出结果**与**预期结果**是否**相符**的过程
- 判断测试属于静态还是动态，仅需要确认是否实际运行了软件



###### **动态测试主要包括**：

1. **功能确认、接口测试**
2. **覆盖率分析**
3. **性能分析**
4. **内存分析**



#### 手工测试与自动化测试

**常用自动化测试工具**：

1. **功能性**自动化测试工具
   - QuickTest Professional
   - Rational Robot
   - Compuware QARun
   - *等*
2. **性能**自动化测试工具
   - LoadRunner
   - MS WAS
   - Rational Robot
   - *等*

**主要理论**：

1. 手工测试与自动化测试都是**不可或缺**的，两者是**相辅相成**的关系。
2. 手工测试与自动化测试都**以测试用例为核心**。
3. 理论上，所有的手工测试都可以改为以自动化的方式来执行，不过应当考虑使用自动化测试工具带来的效率上的增益能否抵消掉项目资金的消耗。



------



### 理论结束：概念当道



### 软件测试用例详解

**软件测试用例 (Test Case)**：**测试目标、输入数据、操作方式、测试环境、预期结果以及测试脚本**的特定**集合**。测试用例可以**体现软件测试的方法、技术与策略，可以用于核实软件是否满足相应的需求**

**软件测试用例可以解决的问题**：

1. 确定需要测试软件的哪些功能。（什么需要测【是什么】）
2. 具体如何执行软件测试。（怎么做）
3. 如何衡量软件测试得出的结果。（怎样做就好）

#### **测试用例的用途**：

- **指导**测试工程师**开展测试工作**。
- **指导**测试工程师**规划测试数据**。
- **指导**测试工程师**编写测试脚本**。
- 作为测试工作成功与否的评判标准。
- 作为软件缺陷严重程度的评判标准。

**补充概念**：

1. 软件测试用例是测试工作的 **“关键”** 部分（软件测试计划是 **“核心”** 部分）。
2. 软件测试用例可以用来测试软件的**某一需求能否得到满足**。
3. 软件测试用例的编写方式**不唯一**，应当**具体问题具体分析**。

**使用软件测试用例的好处**：

- 测试用例可以帮助测试人员**理清思路、避免遗漏**。
- 测试用例可以便于**跟踪测试工作进展**。
- 测试用例可以作为**历史参考**。
- 使用测试用例可以开展**重复测试**。



## 内容与格式

### :one: 内容

**参照已有的软件测试用例模板来编写新的待测软件的测试用例**。**模板不是标准**，**根据待测软件的不同对最终的测试用例进行相应的调整**。

**软件测试用例应当具备以下特性**：

1. **简洁性**：**简单、精炼**的语言来编写测试用例。
2. **正确性**：可以**顺利**的依照测试用例来执行工作，并且得到**准确**的测试结果。

明确 **“测试工程师应当做什么”** ， **“软件应当呈现什么结果”**，case要明确**输入**与**预期输出**。避免语义混淆，**操作步骤**应当**采用** **“动词 + 名词”** 的结构编写

**动词**应当总是 **“测试工程师要做的事情”**，**名词**应当总是 **“测试工程师所操作的对象”**。

### :two: 格式

**软件测试用例的基本格式**：

- **软件名称**
- 软件版本
- 功能模块名称
- 编号
- **测试标题**
- 重要级别
- 前置要求
- **测试数据**
- **测试输入**
- **操作步骤**
- **预期结果**
- *等*

**示例**：

| 软件           | Windows 10                                                   |
| :------------- | :----------------------------------------------------------- |
| 软件版本       | 版本 2004 (OS 内部版本 19592.1001)                           |
| 编号           | 000001                                                       |
| 制作人         |                                                              |
| 制作日期       | 2020 年 4 月 4 日                                            |
| **功能模块名** | **夜间模式**                                                 |
| **测试目的**   | **确认此版本 Windows 下夜间模式能否正常使用**                |
| **测试数据**   | **账户：hnistgkx@outlook.com、密码：password**               |
| **操作步骤**   | **[1. 启动开始菜单] > [2. 点击 “齿轮” 图标] > [3. 点击 “系统”] > [4. 点击 “夜间模式设置”] >** |
|                | **[5. 将 “强度” 滑块拉动至中间位置] > [6. 点击 “立即启用”] > [操作完毕]** |
| **预期结果**   | **在 5 秒钟时间内，屏幕背景颜色由亮白色变为暗黄色，也可能呈现为橙色**。 |
| 测试工程师     | *待填写*                                                     |
| 开发工程师     | *待填写*                                                     |
| 项目负责人     | *待填写*                                                     |

## 三、更新与维护

随着软件项目的**需求变更**与**功能变化**，软件测试用例也需要不断的进行**细化**与**完善**，这是一个**循序渐进**的过程。软件测试用例一般需要由多名**经验丰富**的测试工程师进行**正式、有效**的评审，以便及时的进行查缺补漏。如果确实需要的话，推荐**使用专业的软件来管理软件测试用例**，而不仅仅是将测试用例放置在 Word 文档中。





## 黑盒测试   来啦

### 常用方法：

- **等价类划分法**
- **边界值分析法**
- 因果图法
- 决策表法
- **错误推测法**
- 正交试验法
- 场景法



#### 等价划分法：

依据需求对测试输入数据的范围进行细分，在每个细分区域中选取**有代表性**的测试**数据**，以此测试数据来开展测试工作

**优点**：**数据合理分类**，形成对应的有代表性的测试用例，减轻工作量

**等价类分为以下两种**：等价类 = 有效等价类 + 无效等价类

1. **有效等价类**：**符合**需求说明的**合理**软件测试输入数据的集合。
2. **无效等价类**：**不符合**需求说明的**无意义**软件测试输入数据的集合。

**使用等价类划分法的步骤**：

1. 依据常用方法来为软件的测试输入数据**划分等价类** :arrow_down:
2. 为列表中的每一个等价类规定**唯一**的编号 :arrow_down:
3. 设计一个新的**软件测试用例**，使其可以覆盖**尽可能多**的尚未被覆盖的**有效等价类** :arrow_down:
4. **重复步骤 3**，直至**所有的有效等价类**全部被测试用例覆盖 :arrow_down:
5. 设计一个新的**软件测试用例**，使其**仅覆盖一个**尚未被覆盖的**无效等价类** :arrow_down:
6. **重复步骤 5**，直至**所有的无效等价类**全部被测试用例覆盖 :triangular_flag_on_post:

### :two: 示例

| 软件测试技术                  | 黑盒（等价类划分法）                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 待测试软件                    | 一个可以计算范围均在 **0 - 100** 之间的**两数相加**结果的计算器。 |
| 测试输入数据 **(有效等价类)** | **输入数据 >= 0 且 <= 100**                                  |
| 测试输入数据 **(无效等价类)** | **输入数据 < 0 或 > 100**                                    |
| 测试输入数据 **(无效等价类)** | 不在此列表中的其他测试输入情况                               |

**加数的等价类划分**：

- **数值**
  - 整数
    - **< 0 [1]**
    - **0 - 100 [2]**
    - **&gt; 100 [3]**
  - 浮点数 **[4]**
- **非数值**
  - 字母 **[5]**
  - 特殊字符 **[6]**
  - 空格 **[7]**
  - 无输入 **[8]**

**编写测试用例**：

| 测试用例编号 |        所属等价类        | 加数 1 | 加数 2 |             预期结果             |
| :----------: | :----------------------: | :----: | :----: | :------------------------------: |
|      0       | **[2]** - **有效**等价类 |   5    |   83   |    软件输出 **“88”** 的结果。    |
|      1       | **[2]** - **有效**等价类 |   0    |  100   |   软件输出 **“100”** 的结果。    |
|      2       | **[1]** - **无效**等价类 |   -1   |   5    | 软件输出 **“输入错误”** 的提示。 |
|      3       | **[3]** - **无效**等价类 |  101   |   5    | 软件输出 **“输入错误”** 的提示。 |
|      4       | **[4]** - **无效**等价类 |  1.5   | 70.73  | 软件输出 **“输入错误”** 的提示。 |
|      5       | **[5]** - **无效**等价类 |   G    |   kx   | 软件输出 **“输入错误”** 的提示。 |
|      6       | **[6]** - **无效**等价类 |   $    |   😁    | 软件输出 **“输入错误”** 的提示。 |
|      7       | **[7]** - **无效**等价类 |  空格  |  空格  | 软件输出 **“输入错误”** 的提示。 |
|      8       | **[8]** - **无效**等价类 | 无输入 | 无输入 | 软件输出 **“输入错误”** 的提示。 |
|     ...      |           ...            |  ...   |  ...   |               ...                |



## 三、边界值划分法

### :one: 概念

**边界值划分法**（又称边界值**分析**法）：指的是对软件的输入或输出的**边界值**进行着重测试的一种测试方法。在实际应用中，边界值划分法通常会与等价类划分法共同使用，作为等价类划分法的补充。

**为什么要使用边界值划分法**：**软件中数据范围的边界值是最容易产生错误与缺陷的位置**。因此，如果我们将软件测试的重点放在这些边界值周围，可以有效的提高缺陷的发现效率，并且节省一定的测试工作开销。

### :two: 使用步骤

**使用边界值划分法的步骤**：

1. 输入数据规定了**范围**，则在实施测试时应当选择**范围的边界 [1]**、**略微超出边界 [2]**、**略微低于边界 [3]** 的三种值作为软件测试的输入数据。
   - **示例**：待测试软件为一个可以计算 **0 - 100** 之间的**两整数**相加结果的计算器。当使用边界值划分法进行测试时，可以选择 **0、100、1、101、-1、99** 作为加数的主要测试输入数据，而不必测试例如 “30 + 45” 一类的结果。

2. 如果软件需求中对输入数据规定了**个数**，则在实施测试时应当选择**最大个数 [1]**、**最小个数 [2]**、**最大个数 +1 [3]、最小个数 -1 [4]** 的四种值作为软件测试的输入数据。
   - **示例**：待测试软件为一个可以计算 **4 - 7** 个数字相加结果的计算器。当使用边界值划分法进行测试时，可以选择 **4 个、7 个、3 个、8 个数字**作为加数个数的主要测试输入数据，而不必测试例如 “5 个数字” 或 “6 个数字” 相加时的结果。

3. 如果软件需求中指出输入域或输出域是**有序集合**的话，则在实施测试时应当选择集合中的第一个与最后一个元素作为测试用例。如果软件中使用了**内部数据结构**的话，则应当选择内部数据结构的边界上的值作为测试用例。

**边界值数据的总体选择原则：刚刚等于、刚刚大于、刚刚小于**。



## 四、错误推测法

**错误推测法**：指的是基于软件测试工程师的**经验与直觉**，对软件中可能存在缺陷的功能与模块进行**推测**，并根据这些**推测**有针对性的设计软件测试用例的一种测试方法。

**使用前提**：**深度熟悉**被测试软件、过去已经**系统的分析过**此软件中存在的缺陷。

错误推测法是等价类划分法与边界值划分法等测试方法的**补充**，在实际的软件测试工作中可以**灵活使用**此方法即可，不需要进行详细的学习。



## 五、控件的黑盒测试方法

### :one: 常用控件

- **文本框**
- **按钮**
- **单选按钮**
- **复选框**
- 列表框
- 组合列表框
- 滚动条
- *等*

### :two: 文本框

软件中的**文本框**的测试工作需要考虑以下情况：**内容、长度、类型（大小写 / 是否隐藏*等* ）、唯一性、空文本框、空格、复制粘贴、特殊字符、功能键*等*** 。

**示例**：

等待测试的是某个软件的**账户登录**功能，因此需要对软件的 **“账户文本框”** 与 **“密码文本框”** 分别进行测试。在开展测试工作时，应当按照下方的步骤进行操作：

1. 输入正确的账户名与密码，密码的每一位均显示为 “\*” 符号。点击 “登录” 按钮，可以**成功登录**账户 :arrow_down:
2. 输入正确的账户名与错误的密码（再测试一次错误的账户名与正确的密码）。点击 “登录” 按钮，**无法登录**账户，提示 “用户名或密码错误” :arrow_down:
3. 注册新账户，输入未使用过的账户名，可以**成功注册** :arrow_down:
4. 注册新账户，输入已注册过的账户名，**无法注册**，提示 “用户名已存在” :arrow_down:
5. 软件需求文档中应当已经给出了账户名允许的长度范围。注册新账户，按照 “边界值划分法” 进行测试，注册大于长度范围的账户名，**无法注册**，提示 “用户名过长” :arrow_down:
6. 注册新账户，输入空格账户名，**无法注册**，提示 “用户名不符合要求”。不输入账户名，无法注册，提示 “未输入用户名” :arrow_down:
7. 软件需求文档中应当已经给出了账户名的格式要求（例如不能使用特殊字符 / 汉字等）。注册新账户，输入不允许使用的特殊字符或汉字作为账户名，**无法注册**，提示 “用户名不符合要求” :arrow_down:
8. 软件需求文档中应当已经给出了是否允许在 **“密码文本框”** 中复制粘贴文本。登录或注册新账户，向密码文本框中粘贴文本，确认实际结果是否与预期结果相同 :arrow_down:
9. 软件需求文档中应当已经给出了是否允许注册 **“特殊字符集”** 为账户名。注册新账户，输入类似 “NULL”、“\0” 等特殊字符集为账户名，确认实际结果是否与预期结果相同 :arrow_down:
10. 执行软件测试用例中的其余操作，确认实际结果是否与预期结果相同 :triangular_flag_on_post:

### :three: 按钮

软件中的**按钮**的测试工作需要考虑以下情况：

- **按钮能否实现相应的功能 (例如确认 / 取消*等* )**
- **按钮能否提示正确的信息 (例如正确性 / 友好性 / 二次确认*等* )**
- **对于不符合要求的输入数据，按钮能否进行相应的处理 (例如输入错误 / 查询失败*等* )**

**示例**：待测试软件与上方 “文本框” 部分的示例相同。账户登录的功能除了需要用于输入账户名与密码的两个文本框之外，**还需要一个 “登录” 按钮**。在开展测试工作时，应当注意以下情况：

1. 输入正确的账户名与密码，点击 “登录” 按钮，可以**成功登录**账户 :arrow_down:
2. 输入错误的账户名或密码时，按钮给出 **“用户名或密码错误”** 的提示 :arrow_down:
3. 注册新账户时，应当有 **“密码二次确认”** 的过程，不能只让用户输入一次密码即可完成注册 :triangular_flag_on_post:

> 注：按钮应当具备 **“友好性”**。**可能会导致数据丢失的操作不能在用户点击按钮时立即执行，而是应当弹出 “是否确认执行此操作？” 的提示，让用户进行二次确认**。

### :four: 单选按钮

软件中的**单选按钮**的测试工作需要考虑以下情况：

- **每个按钮是否都能实现相应的功能**
- **一组单选按钮是否只能选中一个**
- **是否有默认的选中项**

### :five: 复选框

软件中的**复选框**的测试工作需要考虑以下情况：

- 多个复选框能否**同时**选中
- 多个复选框能否**部分**选中
- 多个复选框能否**均不**选中
- **每个复选项目是否都能实现相应的功能**
- **多个复选项目是否可以实现叠加的功能**



## 白盒来啦

了解软件的**结构与处理过程**，按照软件的**内部逻辑**来测试软件，**以检验软件中的每条路径能否按照规格说明文档中的规定或要求正常执行**的一种测试技术

**着重**于检查软件的**内部结构、逻辑、循环**与**路径**中存在的错误与缺陷

> 注：白盒测试技术中的 **“边界值测试”** 一般用于检查程序代码中的**数组是否越界、变量是否溢出**等错误。



**逻辑驱动覆盖主要分为以下几种**（按强弱顺序排行）：

1. **条件组合覆盖**（最强）
2. **判定 - 条件覆盖**
3. **条件覆盖**
4. **判定覆盖**
5. **语句覆盖**（最弱）



**语句覆盖测试**：**制定<u>足够多</u>的软件测试用例**，使得软件中的**每一个代码语句至少都能被执行一次**的软件测试方法。效果**较差**

**判定覆盖测试**：指的是制定足够多的软件测试用例，使得软件中的**每一个分支至少都能被执行一次**的软件测试方法。这是一种比 “语句覆盖测试” 效果**稍强一些**的逻辑驱动覆盖测试方法

**条件覆盖测试**：指的是制定足够多的软件测试用例，使得软件中的**每一个判定条件都获得各种可能的取值**的软件测试方法。这是一种效果**更强一些**的逻辑驱动覆盖测试方法

**判定 - 条件覆盖**：顾名思义，指的是**综合**判定覆盖与条件覆盖，制定足够多的软件测试用例，使得软件**判定中的每一个条件都获得各种可能的取值**，同时使得软件中的**每一个分支至少都能被执行一次**的软件测试方法

**条件组合覆盖**：指的是制定足够多的软件测试用例，使得软件中的**所有条件的各种组合都能被至少执行一次**的软件测试方法。这是效果**最强**但**仍不完美**的逻辑驱动覆盖测试方法

”不完美但是足以应对大多数的测试“

”通常**不必直接使用条件组合覆盖测试方法**，因为会大幅度的增加测试工程师的工作量。一般情况下，大多数的软件测试工作只需使用**语句覆盖**与**判定覆盖**这两种逻辑驱动覆盖测试方法“



### 来学习软件缺陷啦

软件中存在的某种可以**破坏软件正常运行能力**的**问题、错误**或隐藏在软件功能中的**缺陷**

一切的程序、系统与文档中的问题，实际软件与需求说明文档中不一致的情况，软件无法满足用户需求的情况等，全部可以被视为**软件缺陷**

**从软件的内部来看**，软件缺陷指的是软件在开发或维护的过程中所存在的错误与其他各种问题。**从软件的外部来看**，软件缺陷指的是软件与其所需要实现的功能的失效与违背

一般情况下，满足以下情况**之一**，即可称为软件缺陷：

1. 软件未实现产品说明文档中要求的功能。（需求缺失）
2. 软件出现了产品说明文档中明确指出了的 “不应当出现” 的错误。（bug&忘记实现）
3. 软件实现了产品说明文档中未要求实现的功能。（bug or 理解错误）
4. 软件未实现产品说明文档中未要求实现、但是实际上应当实现的功能。（隐形需求）
5. 软件难以使用、不易使用、运行缓慢或最终用户不满意（易用性差）

**软件缺陷并不全部被称为 Bug，也有其他的称呼方式**：

- **缺陷**（Defect）
- **故障**（Fault）
- **问题**（Problem）
- **错误**（Error）
- **异常**（Anomy）
- **差异**（Variance）
- **失败**（Failure）
- **矛盾**（Inconsistency）
- **事故**（Incident）

”多数的缺陷都存在于**软件产品说明书**（需求规格说明文档）中“

> 软件开发流程中**最早**开展的 **“需求”** 阶段存在最多的缺陷，同时随着时间的推移，修复软件缺陷的成本将会**呈指数级增长**，因此，在软件开发工作的各个流程都开展**审查**与**评审**是非常有必要的。

**要求**：

- **需求评审非常重要**。
- **设计评审必不可少**。
- **文档更新应当及时**。
- **开发测试仔细思考**。



## 软件缺陷的严重性与优先级

 严重性用来表示缺陷所造成的危害的恶劣程度

1. **致命缺陷**（Fatal）：指的是可以直接造成软件**崩溃、挂起、冻结**或**无响应**，或者可以造成软件**数据丢失**或**主要功能完全失效**等致命问题的软件缺陷。
2. **关键缺陷**（Critical）：指的是可以造成软件的**主要功能部分失效**或者**次要功能完全失效**的软件缺陷。
3. **主要缺陷**（Major）：指的是**几乎不影响**软件正常使用，但是**没有完全实现需求**、**未能达到预期效果**的软件缺陷。
4. **次要缺陷**（Minor）：指的是**完全不影响**软件正常使用的**细微**的软件缺陷。
5. **建议**（Suggestion）：软件产品用户提出的友好建议



**优先级**用来表示**修复缺陷时应当遵循的先后顺序**。一般情况下，缺陷的优先级可以使用字母 A、B、C、D 或数字 1、2、3、4 进行划分，A (1) 表示最高级别，D (4) 表示最低级别。P（1），P（2）。

- **A - 1 - 最高优先级**：停止进一步的测试与开发工作，**立即**修复此缺陷。
- **B - 2 - 次高优先级**：在软件正式发布前**必须**修复此缺陷。
- **C - 3 - 中等优先级**：如果时间允许的话，**应当**修复此缺陷。
- **D - 4 - 最低优先级**：**可以**修复此缺陷，也可以不修复



**软件缺陷状态**主要分为以下几种：

|              软件缺陷状态               |                             详解                             |
| :-------------------------------------: | :----------------------------------------------------------: |
|    **激活 / 开启**（Active / Open）     |               新提交的软件缺陷，正在等待处理。               |
|     **已修复**（Fixed / Resolved）      |   软件开发工程师已经检查并修复此缺陷，但尚未执行回归测试。   |
|      **关闭**（Closed / Inactive）      |      软件测试工程师已经执行回归测试，确认缺陷不再存在。      |
|           **重启**（Reopen）            |      软件测试工程师已经执行回归测试，发现缺陷仍然存在。      |
|          **推迟**（Deferred）           |              这个软件缺陷将在下一个版本中修复。              |
|           **保留**（On Hold）           |         由于某些技术原因，这个软件缺陷暂时无法修复。         |
|    **无法重现**（Cannot Duplicate）     | 软件开发工程师无法重现这个缺陷，需要测试工程师提供重现步骤。 |
|   **需要更多信息**（Need More Infor）   |     缺陷可以重现，但仍需要更多详细信息，例如日志文件等。     |
|          **重复**（Duplicate）          |           这个软件缺陷已经被其他的测试工程师发现。           |
|         **非缺陷**（Not A Bug）         |                   这个问题并非是软件缺陷。                   |
| **需要修改规格说明书**（Spec Modified） | 根据软件规格说明书的相关要求，这个缺陷无法修复，除非先行修改规格说明书。 |



### :one: 软件缺陷报告的用途

- **记录软件缺陷**
- **分类软件缺陷**（便于分配资源）
- **跟踪软件缺陷的处理情况**

只要软件仍然处于生命周期之内，测试工程师无论在任何情况下发现缺陷，都应当及时编写并提交缺陷报告。

### :two: 编写软件缺陷报告时应当注意以下几点

1. **确保问题可以重现**：一个优秀的软件缺陷报告应当可以让其他技术工程师**轻松、快速**的重现问题。
2. **对缺陷进行分析**（使用最少的步骤重现问题）：便于开发工程师准确定位软件缺陷的成因。
3. **包含重现问题的所有必要步骤**。
4. **方便阅读**。
5. **每个软件缺陷报告只记录一个问题**。
6. **理性编写报告，注意语气态度**。



### 软件缺陷报告​

|  软件缺陷报告  |                             示例                             |
| :------------: | :----------------------------------------------------------: |
|      编号      |                           AA8fkj1                            |
|      时间      |                      2020 年 4 月 3 日                       |
|     提交者     |             Ling Gao (Microsoft Windows Insider)             |
| Windows 版本号 |                  Windows 10_1909_18363.752                   |
|      问题      | 在任务栏搜索框中输入待搜索文本后，无法搜索到任何 Web 结果。  |
|    处理情况    |                      已修复 - Resolved                       |
| 开发工程师答复 | Thanks for reaching out about this - inline web results in Search should now be back up and running for all supported regions. —— Jennifer (Microsoft Engineer) |

[缺陷报告实例](https://github.com/Lingggao/SDIR#software-defect-investigation-report)



**单元**：指的是软件中具有**明确的功能**与**完整的规格、接口定义**，可以清晰的与软件中其他部分**区分开来**的某一个部分。单元没有标准划分法，可以完全依照测试工程师的自身想法进行划分

**单元测试**：单元测试（亦称模块测试）：指的是对软件组成中的**最小可测试单元**进行的测试。单元测试将会检查软件中的各模块是否存在缺陷，是编码阶段结束后、测试工作开始时的**第一项**测试工作。

- **目标**：确保软件中的每个模块都能正常工作。
- **开始时间**：...... -> *详细设计* -> 编码 -> 编译 -> **单元测试** -> 集成测试 -> 系统测试 -> ......
- **设计依据**：详细设计说明书、源代码。***[详见下图 ]***
- **执行者**：软件开发工程师或白盒测试工程师。
- **执行方式**：以**白盒测试技术**为主。首先执行**静态测试**，检查软件代码是否符合规范。随后执行**动态测试**，检查模块的实际输出结果与预期结果是否相符。



## 二、测试内容

单元测试主要针对以下**五个方面**对软件单元进行测试：

1. **边界条件**
2. **异常处理**
3. **模块接口**
4. **局部数据结构**
5. **程序路径**

## 三、辅助测试模块

在执行单元测试时，如果被测试模块并不是一个独立的程序，那么就需要设置**辅助测试模块**：

- **驱动模块 (Drive)**：用于模拟被测试模块的**上一级**模块。驱动模块相当于被测模块的 **“主程序”**，通常负责接收测试数据、将数据传递给被测模块、启动被测模块、输出测试结果等。
- **桩模块 (Stub)**：用于模拟被测模块在工作过程中所调用的**子**模块，负责进行少量的数据处理





### 集成测试来啦

集成测试 (Integration Test)** (亦称综合测试、组装测试、联合测试)：指的是在**单元测试**工作完成之后，按照软件在设计阶段时所确定的**结构图**将每一个模块**连接**起来，进行进一步测试的流程。

- **目标**：软件中的各单元连接完毕后可以正常协同工作、软件行为正常。
- **测试内容**：各单元间的接口、集成后的功能。
- **开始时间**
  - ...... -> *详细设计* -> 编码 -> 编译 -> 单元测试 -> **集成测试** -> 系统测试 -> ......  **(理论)**。
  - 集成测试与单元测试同步进行 **(实际工作)**。

## 二、测试内容

集成测试主要针对以下**五个方面**对软件单元进行测试：

1. 数据在软件各单元的接口之间传输时是否会出现丢失。
2. 某个模块是否会破坏另一个模块的功能。
3. 各个子功能组装完毕后能否实现主功能。
4. 全局数据结构是否存在问题。
5. 是否存在误差堆积的问题。

> 注：集成测试一般由开发工程师与测试工程师共同完成，结合使用白盒与黑盒测试方法。

## 三、测试形式

<img src="https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/3_2_%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95.png?raw=true" width = "70%" />

### :one: 非增量式测试

**非增量式测试**（先分散再集中）：指的是使用**一步到位**的方法来构造测试，在软件各个相关联模块均完成单元测试后，直接将多个模块集成起来，共同开展集成测试工作。**在实际工作中，一般不使用非增量式测试**。

- **优点**：节省时间。
- **缺点**：难以定位与修复缺陷、可能导致新旧缺陷混杂。

### :two: 增量式测试

**增量式测试**（逐步集中与测试）：指的是使用**逐步集成**的方法来构造测试。增量式测试方法**优于**非增量式测试方法，具体分为 **“自顶向下”、“自底向上”、“混合增量”** 三种形式，将通过下方的示例进行详细介绍。

示例：假设待测试软件的各模块**结构图**如下：

<img src="https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/3_2_%E7%BB%93%E6%9E%84%E5%9B%BE.png?raw=true" width = "40%" />

1. **自顶向下**：首先找到**主控模块**（亦称关键模块），主控模块通常至少具备以下特征之一：

   - 满足软件的主要需求。
   - 在软件的模块结构中位于较高层次。
   - 复杂且易出错。
   - 有明确定义了的性能要求。

   **将主控模块作为测试驱动器，根据集成方式，将下层的桩模块依次替换为真正的软件模块进行测试**。在每个模块被集成时，都要先进行单元测试。按照**深度优先**或**广度优先**的方式进行集成。

   - **深度优先方式**：优先集成软件结构中的某一个主控路径下的所有模块，路径可以任意选择。
   - **广度优先方式**：沿着水平方向依次将每一层中直接隶属于上一层的模块集成起来，直到最后一层。

   以上方的待测试软件为例，深度优先与广度优先的集成顺序分别如下图所示 (按**红橙黄绿蓝紫**颜色顺序)：

<img src="https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/3_2_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88.png?raw=true" width = "40%" /><img src="https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/3_2_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88.png?raw=true" width = "40%" />

2. **自底向上**：与自顶向下形式**相反**，从底层模块逐渐向主控模块进行测试 (按**红橙黄绿蓝紫**颜色顺序)：

<img src="https://github.com/Lingggao/Software-Testing-Basics/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/3_2_%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A.png?raw=true" width = "40%" />

3. **混合增量**：将自顶向下与自底向上两种形式**混合使用**，同时利用二者优点并摒弃缺点。在实际工作中，一般会优先测试**输入输出模块**与**引入了新算法的模块**（衍变了的自顶向下形式）。

### :three: 比较

**自顶向下与自底向上测试方式的比较**：

|      |                      自顶向下增量式测试                      |                      自底向上增量式测试                      |
| ---- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 优点 | 可以做到逐步求精、可以直接的看到系统框架、容易发现上层接口存在的缺陷、不需要驱动模块。 | 容易发现底层模块中存在的缺陷、驱动模块可以模拟所有调用参数，便于生成测试数据。 |
| 缺点 | 需要提供桩模块、底层模块中的缺陷发现时间较晚、如果未接入输入输出模块的话，难以在桩模块中表示测试数据。 |        直至最后一个模块继承完毕后才可以看到系统框架。        |

---





### 系统测试他来啦他来啦

指的是将软件产品看作为一个**整体**，对包括**功能、性能、兼容性、安全性、易用性**等方面进行测试。系统测试将**计算机硬件、配套软件、数据、人员**等系统元素结合起来，在**实际运行环境**下开展测试工作。系统测试工作由**黑盒测试工程师**或**专门测试工程师**（例如性能测试工程师、安全测试工程师等）负责

系统测试主要分为以下几种：

- **功能测试**
- **兼容性测试**
- **界面测试**
- **易用性测试**
- **性能测试**
- **安全性测试**
- 国际化 / 本地化测试
- 安装测试
- 文档测试



**功能测试**：指的是对软件产品的各个**功能点**进行验证的测试流程。功能测试以**需求规格说明书**与**功能性测试用例**为依据逐项进行测试，检查软件产品是否满足用户需求。测试内容主要包括**业务测试**、**通过测试**与**失败测试**。

**增、删、查、改**功能的常用功能测试点示例：

### :one: 新增

1. 必填栏位测试。
2. 栏位值是否可以重复。
3. 栏位格式是否正确。
4. 栏位新增权限测试。
5. 自动填充栏位测试。
6. 提交与重置功能是否可以正常工作。
7. 提交成功时，数据库中是否增添了对应的数据。
8. 提交失败时，数据库中是否错误的增添了对应的数据。
9. 通过与失败时的提示信息是否正确。
10. 时间限制功能测试。
11. *等*

### :two: 删除

1. 二次确认功能测试。
2. 是否在数据库中彻底删除对应的数据。
3. 全选删除、取消全选功能测试。
4. 未选中任何待删除数据时，删除按钮能否成功按下。
5. 多页显示时，删除某一页中的所有数据后，能否自动弹回至上一页。
6. 删除权限验证测试。
7. *等*

### :three: 查询

1. 是否可以成功查询数据库中的已有数据。
2. 将查询条件或查询内容置空后进行测试。
3. 输入特殊字符作为查询内容进行测试。
4. 查询结果能否正常分为多页。
5. 重置查询条件的按钮是否可以正常工作。
6. 在查询内容中插入空格，测试能否正常查询到结果。
7. 使用边界值划分法测试查询条件的边界。
8. 使用多个条件进行查询，测试查询结果是否同时符合所有条件。
9. 模糊查询功能测试。
10. *等*

### :four: 修改

1. 必填栏位测试。
2. 栏位值是否可以重复。
3. 栏位格式是否正确。
4. 自动填充栏位测试。
5. 测试能否正常带出所需资料。
6. 修改权限验证测试。
7. 测试只读数据能否被修改。
8. 提交与重置功能是否可以正常工作。
9. 测试修改完毕后能否成功显示新数据。



### 兼容性测试：

**兼容性测试**：指的是对软件产品在特定的**硬件平台**以及不同的**软件、操作系统、网络**等环境中能否正常运行的测试流程。

### :one: ​兼容性测试的作用

- 尽可能的提高软件产品的质量。
- 尽可能的让软件产品与其他第三方软件 “和平共处”。
- 尽可能的确保软件产品的存在价值。
- 尽可能的使软件产品的市场更加广阔。

### :two: ​兼容性测试的主要关注内容

1. **向前兼容**：可以使用软件的未来版本（例如 Word 97 - 2003 文档可以在 Microsoft 365 中打开）。
2. **向后兼容**：可以使用软件的过去版本（例如 Microsoft 365 的 docx 格式文档可以在 Word 2003 中打开）。
3. **不同版本间兼容**：实现测试平台与软件的多个版本间可以正常工作。
4. **标准与规范**：遵守相应的软件平台标准与规范（例如 Microsoft Windows 徽标认证）。
5. **数据共享兼容**：支持并遵守相应的标准，允许用户从软件中向外部传输数据。

### :three: ​兼容性测试用例的制定原则

- **流行程度**：优先在主流平台中开展测试。
- **类型**：优先针对常用类型的平台开展测试。
- **厂商**：优先针对主流厂商的平台开展测试。
- **年限**：优先选择未被淘汰掉的平台开展测试。



## 界面测试

**界面测试**：指的是对软件产品的**用户界面**进行验证的测试流程。界面测试通常用于验证软件产品的界面布局是否合理、风格是否一致、控件位置是否合理、文字是否准确、内容是否美观等。

**界面测试的主要关注内容**：

- **风格**
- **正确性**
- **一致性**
- **合理性**
- **美观性**
- **协调性**

## 易用性测试

**易用性测试**：指的是对软件产品在使用上的**合理性**与**方便性**进行验证，进而发现 “不方便用户使用” 的情况的测试流程。软件产品应当尽可能的实现 **“三容易”**，即 **“容易理解”、“容易学习”、“容易操作”**。

**易用性测试的常用测试点示例**：

1. 软件中的常用功能应当有对应的快捷键或快捷按钮。
2. 功能相同或相近的控件应当放置在同一区域。
3. 如果某个操作可能需要花费较长时间，则应当提供进度条与 “取消操作” 按钮。
4. 功能按钮的图标应当直观的表示此按钮所对应的操作。
5. 软件应当提供友好的疑难解答与技术支持。
6. 可以一步完成的操作，不应当分为两步来显示。
7. *等*

## 六、性能测试
